# Отчёт. Домашнее задание 2. Вариант 3.
## _Шарапов Егор Сергеевич, БПИ219_

В данном отчете представлены действия, проделанные для работы.\
У каждого блока действий можно найти путь до папки в котором вы сможете сами увидеть все изменения и тесты в папках **Test**.\
**Исходные программы на ассемблере будут находится в файлах, также как и разделеные программы (7 и 8) на С, если бы они тут были, отчет бы приобрел гиганские масштабы и стал бы не читаем. Поэтому советую пользоваться ссылками в отчете.**
> Рекомендую открыть всю папку как проект в **VScode** или **Atom** и удобно и быстро прыгать по ссылкам на файлы из отчета.

## Условие 
> Разработать программу, находящую в заданной ASCII-строке первую слева направо последовательность N символов, каждый элемент которой определяется по условию «меньше предшествующего» (N вводится как отдельный параметр).

*В работе выполнены требования на 8.*

## Содержание 
- [Начало](#отчёт-домашнее-задание-2-вариант-3)
- [Выполнено на 4](#4-балла) 
- [Выполнено на 5](#5-баллов) 
- [Выполнено на 6](#6-баллов) 
- [Выполнено на 7](#7-баллов) 
- [Выполнено на 8](#8-баллов) 
- [Завершение](#конец-отчета)

## 4 балла
**Путь:** 
[./4_points](./4_points)
- Решение на языке С представлено в файле [**main.c**](./4_points/main.c) (не используются глобальные переменные)
```sh
#include <stdio.h>
int main() {
    int N = 0;
    int size_of_string = 0;
    int counter = 0;
    int index_start = 0;

    while (N <= 1 || N >= 100) {
        printf("Введите N (длину искомой убывающей последовательности): ");
        scanf("%d", &N);
    }
    while (size_of_string  <= 1 || size_of_string  >= 10000) {
        printf("Введите длину cтроки: ");
        scanf("%d", &size_of_string);
    }
    char str[size_of_string];
    printf("Введите строку размера [%d]: ", size_of_string);
    scanf("%s", str);
    printf("Начинаем поиск первой убывающей последовательности размера [%d]\n\n", N);
    for (int i = 0; i < size_of_string; i++) {
        if (counter == N)
        {
            printf("Последовательность из [%d] символов найдена!\n", N);
            break;
        }
        if (counter == 0) {
            if (i > 0)
            {
                index_start = i;
                counter++;
            }
        }
        if (str[i-1] > str[i]) {
            counter++;
        } else {
            counter = 0;
            index_start = i;
            continue;
        }
        if (i == size_of_string - 1)
        {
            if (counter == N)
            {
                printf("Последовательность из [%d] символов найдена!\n", N);
                break;
            }
            printf("Ничего не найдено!\n");
            return 0;
        }
    }
    if (counter != N)
    {
        printf("Ничего не найдено!\n");
        return 0;
    }
    printf("Ответ:\n[%d]: ", N);
    for (int i = index_start-1; i < index_start+counter-1; i++)
    {
        printf("%c", *(str+i));
    }
    printf("\n-----------------------\n\n");
}
```
- Откомпилирована ассемблерная программа, добавлены комментарии, поясняющие использование переменных в языке С и печать информации.
```sh
$gcc -masm=intel -S main.c
```
Добавлены поясняющие комментарии в блоки .main и основные .Lxx.\
Конечный файл [**main.s**](./4_points/) переименован в [**main[with_macros_commented].s**](./4_points/main%5Bwith_macros_commented%5D.s)\
Программа откомпилирована без опций отладки.
```sh
$gcc main[with_macros_commented].s
```
Файл [**a.out**](./4_points/) переименован в [**main_macros_commented.out**](./4_points/main_macros_commented.out)

- Из ассемблерной программы убраны лишние макросы
```sh
$gcc -masm=intel -S -fno-asynchronous-unwind-tables \
>-fcf-protection=none main.c
```
Поясняющие комментарии все еще будут находится в [**main[with_macros_commented].s**](./4_points/main%5Bwith_macros_commented%5D.s)
Скомпилированная без опций отладки программа [**main.s**](./4_points/) переименована в [**main[without_any_macros_and_comments].s**](./4_points/main%5Bwithout_any_macros_and_comments%5D.s)
- Модифицированная ассемблерная программа откомпилирована
и скомпонована без использования опций отладки.
```sh
$gcc main[without_any_macros_and_comments].s
```
Файл [**a.out**](./4_points/) переименован в [**main_nomacros.out**](./4_points/main_nomacros.out)
- Тесты  и их результаты для обеих программ представлены в папке [**Tests**](./4_points/Tests/)
> В файле [*Tests.txt*](./4_points/Tests/Tests.txt) представлены 12 тестов.\
> В файле [*Resaults_f.txt*](./4_points/Tests/Resaults_f.txt) представлены результаты для первой программы.\
> В файле [*Resaults_s.txt*](./4_points/Tests/Resaults_s.txt) представлены результаты для второй программы.\
> Результаты одинаковы для обеих программ.

Пример тестов 

```sh
Test-1:
2
2
98
---------------
Test-2:
3
10
abczyxdefi
---------------
Test-3:
4
10
zyxzutsrqp
---------------
Test-4:
5
10
zyxzutsrqp
---------------
Test-5:
3
6
utsopq
---------------
Test-6:
4
10
7598768931
---------------
Test-7:
4
10
9876893175
---------------
Test-8:
2
10
7598768931
---------------
Test-9:
4
10
7589319876
---------------
Test-10:
7
15
987:WK@?>9!ghty
---------------
Test-11:
10
10
utsrq@=987
---------------
Test-12:
10
10
utsrq@=989
---------------
```

## 5 баллов
**Путь:** 
[./5_points](./5_points)
- Решение на языке С представлено в файле [**main_f.c**](./5_points/main_f.c) (используются локальные пременные и функции с предачей по параметрам)
```sh
int get_N() {
    int N = 0;
    while (N <= 1 || N >= 100) {
        printf("Введите N (длину искомой убывающей последовательности): ");
        scanf("%d", &N);
    }
    return N;
}

int get_size_of_string() {
    int size_of_string = 0;
    while (size_of_string  <= 1 || size_of_string  >= 10000) {
        printf("Введите длину cтроки: ");
        scanf("%d", &size_of_string);
    }
    return size_of_string;
}

void get_string(char str[], int size_of_string) {
    printf("Введите строку размера [%d]: ", size_of_string);
    scanf("%s", str);
}

void find_index_count(char str[], int size_of_string, int N, int counter_index[]) {
    int counter = 0;
    int index_start = 0;
    printf("Начинаем поиск первой убывающей последовательности размера [%d]\n\n", N);
    for (int i = 0; i < size_of_string; i++) {
        if (counter == N) {
            printf("Последовательность из [%d] символов найдена!\n", N);
            break;
        }
        if (counter == 0) {
            if (i > 0)
            {
                index_start = i;
                counter++;
            }
        }
        if (str[i-1] > str[i]) {
            counter++;
        } else {
            counter = 0;
            index_start = i;
            continue;
        }
    }
    counter_index[0] = index_start;
    counter_index[1] = counter;
}

void print_answer(int index_start, int counter, int N, char str[]) {
    if (counter != N) {
        printf("Ничего не найдено!\n");
    } else {
        printf("Ответ:\n[%d]: ", N);
        for (int i = index_start-1; i < index_start+counter-1; i++) {
            printf("%c", *(str+i));
        }
    }
    printf("\n-----------------------\n\n");
}

int main() {
    int N = get_N();
    int size_of_string = get_size_of_string();
    char str[size_of_string];
    get_string(str, size_of_string);
    static int counter_index[2];
    find_index_count(str, size_of_string, N, counter_index);
    int index_start = counter_index[0];
    int counter = counter_index[1];
    print_answer(index_start, counter, N, str);
}
```
- В асемблерное представление программы в файле [**main[separated_into_func].s**](./5_points/main%5Bseparated_into_func%5D.s) добавлены комментарии описывающие передачу фактических параметров и перенос возвращаемого результата и связь между параметрами языка С и регистрами.
- Скомпилированная программа [**main[separated_into_func].s**](./5_points/main%5Bseparated_into_func%5D.s) представлена в файле [**main_separated_into_func.out**](./5_points/main_separated_into_func.out)
> Тесты для прошлых программ также на ней выдают корректный результат.

## 6 баллов
**Путь:** 
[./6_points](./6_points)
- Выполнен рефакторинг программы на ассемблере за счет максимального использования регистров процессора. Программа на ассемблере в [**main[refactor_min_var].s**](./6_points/main%5Brefactor_min_var%5D.s)
- В [**main[refactor_min_var].s**](./6_points/main%5Brefactor_min_var%5D.s) добавлены комментарии, поясняющих использование регистров вместо переменных исходной программы на C.

- Сопоставлены размеры
> Для сравнения с коментариями обьем текущей программы на ассемблере 440 строк, что на 130 строк меньше предыдущей программы.
- Тесты  и их результаты для програмы представлены в папке [**Tests**](./6_points/Tests/)
> В файле [*Tests.txt*](./6_points/Tests/Tests.txt) представлены 12 тестов.\
> В файле [*Resaults_t.txt*](./6_points/Tests/Resaults_t.txt) представлены результаты для третьей программы.\
> Результаты одинаковы для всех трех программ.

## 7 баллов
**Путь:** 
[./7_points](./7_points)
- Выполнена реализация программы на ассемблере, в виде двух единиц компиляции (с файлами).\
Компиляцию можно производить как на основе двух единиц компиляции на коде С:
```sh
$gcc -c functions.c -o functions.o
$gcc -c main_files.c -o main_files.o
$gcc functions.o main_files.o -o main_files_sep
```
Конечный исполняемый файл представлен в [**main_files_sep**](./7_points/main_fiels_sep).\
Так и на основе ассемблерного кода с помощью [**makefile**](./7_points/makefile):
```sh
$make -f makefile
```
Две единицы компиляции представлены c помощью файлов [**functions.o**](./7_points/functions.o) и [**main_files.o**](./7_points/main_files.o).
> Можете также обратить внимания на исходные файлы на С в файлах [**main_files.c**](./7_points/main_files.c), [**functions.h**](./7_points/functions.h) и [**functions.c**](./7_points/functions.c).
- Добавлена возможность задания файлов с исходными данными и файла для вывода результатов с использованием аргументов командной строки. Производится проверка на колличество аргументов и проверка файлов с выводом ошибки и их созданием. Исходный код на С находится в [**main_files.c**](./7_points/main_files.c), в свою очередь ассемблерный в [**main_files.s**](./7_points/main_files.s) и [**functions.s**](./7_points/functions.s). Скомпилированы два исполняемых файла [**main_files**](./7_points/main_files) и [**main_files.out**](./7_points/main_files.out)
```sh
$./main_files ./in.txt ./out.txt
```

**Если оба файла отсутсвуют, файл ввода будет создан и работа продолжена, но ответ в виде выходного файла (если его нет он тоже создаётся) будет пуст, сообщение об отсуствии файла выведется в консоль**

Если не заданы файлы, то программа продолжает работу в обычном режиме.
```sh
$./main_files
```
То же можно реализовать и с помощью скомпилированного ассемблерного кода [**main_files.out**](./7_points/main_files.out)
```sh
$./main_files.out ./in.txt ./out.txt
```
Если не заданы файлы, то программа продолжает работу в обычном режиме.
```sh
$./main_files.out
```
> В файле [**in.txt**](./7_points/in.txt) присутсвуют входные данные, которые содержат ответ (через in также прогонялись все тесты из тестовой папки)

> В файле [**in_have_answer.txt**](./7_points/in_have_answer.txt) присутсвуют входные данные, которые содержат ответ

> В файле [**in_no_answer.txt**](./7_points/in_no_answer.txt) присутсвуют входные данные, которые не содержат ответ

- Тесты  и их результаты для програмы представлены в папке [**Tests**](./7_points/Tests/)
> В файле [*Tests.txt*](./7_points/Tests/Tests.txt) представлены 12 тестов.\
> В файле [*Resaults_f.txt*](./7_points/Tests/Resaults_f.txt) представлены результаты для четвертой программы. *(результаты у ассемблерной программы и С совпадают)*\
> Результаты одинаковы для всех четырех программ.

## 8 баллов
**Путь:** 
[./8_points](./8_points)
- Добавлен генератор случайных наборов данных, расширяющий возможности тестирования
```sh
$./main_g
Выберете тип ввода.
-----------
1) Вручную
2) Автоматически
Введите число (1 или 2):
```
Программа автоматически генерирует входные данные при выборе опции 2.
- Расширен анализ командной строки для выбора способа порождения
исходных данных.
```sh
$./main_g -g
Сгенерированно число N = 3
Сгенерирован размер строки = 933
Cтрока [933]: <вся строка>
Начинаем поиск первой убывающей последовательности размера [3]

Последовательность из [3] символов найдена!
Время исполнения программы: 0.000016
Ответ:
[3]: s4(
-----------------------
```
Программа сразу генерирует исходные данные при использовании опции -g.\
Оригинальный исходный код вы можете найти в [**main_g.c**](./8_points/main_g.c) и исполняемом [**main_g**](./8_points/main_g)
> Генерация правда выполняет создания приемлемых обьемов входных данных для более ли менее корректного отображения в консоли.
- Добавлены замеры во времени, которые не учитывают время ввода и вывода данных. 
```sh
  clock_t begin = clock();
  find_index_count(str, size_of_string, N, counter_index);
  clock_t end = clock();
  double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
  printf("Время исполнения программы: %f\n", time_spent);
```
- Увеличено времени работы минимум до 1 секунды, за счет зацикливания исполнения:
```sh
    // Увеличиваем время исполнения!
    for (size_t i = 0; i < 444; i++) {
        find_index_count(str, size_of_string, N, counter_index);
    }
```
Представленное зациклевание вы можете найти в файлах [**main_g_X444.с**](./8_points/main_g_X444.c) и рефакторинговой [**main_g_X444.s**](./8_points/main_g_X444.s). Исполняемые файлы [**main_g_X444_C**](./8_points/main_g_X444_C) и [**main_g_X444_ASM.out**](./8_points/main_g_X444_ASM.out).\
\
Перейдем к замерам.\
Для быстроты проведения использовалась генерация входных данных в файл [**in.txt**](./8_points/in.txt) и считывание времени через парсинг ответа программы с помощью **Python**.\
Проводилось 100 ссесий [при случайном размере от 500000 до 1000000] и случайном небольшом N на одинаковых входных файлах для двух программ.\
Для оценки скорости работы при генерации создавались убывающие последовательности не более N, чтобы просчитать за сколько программа полностью обработает поступившую строку. 
![](./images/T1.jpg)
![](./images/T2.jpg)
 В среднем ассемблер оказался на **52,27%** быстрее.

> В файле [**in_have_answer.txt**](./8_points/in_have_answer.txt) присутсвуют входные данные, которые содержат ответ

> В файле [**in_no_answer.txt**](./8_points/in_no_answer.txt) присутсвуют входные данные, которые не содержат ответ

- Результаты тестирования для программ представлены в папке [**Tests**](./8_points/Tests/)
> В файле [*TimeTests.txt*](./8_points/Tests/TimeTests.txt) представлен автоматически сгенерированный отчет по времени для случайных тестов.\
> В файле [*TimeTestsTable.xlsx*](./8_points/Tests/TimeTestsTable.xlsx) представлен ручной отчет по времени для случайных тестов c графиками.


# Конец отчета